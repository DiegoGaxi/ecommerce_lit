{
  "version": 3,
  "sources": ["../../@open-wc/dedupe-mixin/src/dedupeMixin.js", "../../@open-wc/scoped-elements/html-element.js", "../../@open-wc/testing-helpers/src/scopedElementsWrapper.js"],
  "sourcesContent": ["const appliedClassMixins = new WeakMap();\n\n/** Vefify if the Mixin was previously applyed\n * @private\n * @param {function} mixin      Mixin being applyed\n * @param {object} superClass   Class receiving the new mixin\n * @returns {boolean}\n */\nfunction wasMixinPreviouslyApplied(mixin, superClass) {\n  let klass = superClass;\n  while (klass) {\n    if (appliedClassMixins.get(klass) === mixin) {\n      return true;\n    }\n    klass = Object.getPrototypeOf(klass);\n  }\n  return false;\n}\n\n/** Apply each mixin in the chain to make sure they are not applied more than once to the final class.\n * @export\n * @param {function} mixin      Mixin to be applyed\n * @returns {object}            Mixed class with mixin applied\n */\nexport function dedupeMixin(mixin) {\n  return superClass => {\n    if (wasMixinPreviouslyApplied(mixin, superClass)) {\n      return superClass;\n    }\n    const mixedClass = mixin(superClass);\n    appliedClassMixins.set(mixedClass, mixin);\n    return mixedClass;\n  };\n}\n", "import { dedupeMixin } from '@open-wc/dedupe-mixin';\n\n/**\n * @typedef {import('./types.js').ScopedElementsHost} ScopedElementsHost\n * @typedef {import('./types.js').ScopedElementsMap} ScopedElementsMap\n */\n\nconst version = '3.0.0';\nconst versions = window.scopedElementsVersions || (window.scopedElementsVersions = []);\nif (!versions.includes(version)) {\n  versions.push(version);\n}\n\n/**\n * @template {import('./types.js').Constructor<HTMLElement>} T\n * @param {T} superclass\n * @return {T & import('./types.js').Constructor<ScopedElementsHost>}\n */\nconst ScopedElementsMixinImplementation = superclass =>\n  /** @type {ScopedElementsHost} */\n  class ScopedElementsHost extends superclass {\n    /**\n     * Obtains the scoped elements definitions map if specified.\n     *\n     * @type {ScopedElementsMap=}\n     */\n    static scopedElements;\n\n    static get scopedElementsVersion() {\n      return version;\n    }\n\n    /** @type {CustomElementRegistry=} */\n    static __registry;\n\n    /**\n     * Obtains the CustomElementRegistry associated to the ShadowRoot.\n     *\n     * @returns {CustomElementRegistry=}\n     */\n    get registry() {\n      return /** @type {typeof ScopedElementsHost} */ (this.constructor).__registry;\n    }\n\n    /**\n     * Set the CustomElementRegistry associated to the ShadowRoot\n     *\n     * @param {CustomElementRegistry} registry\n     */\n    set registry(registry) {\n      /** @type {typeof ScopedElementsHost} */ (this.constructor).__registry = registry;\n    }\n\n    /**\n     * @param {ShadowRootInit} options\n     * @returns {ShadowRoot}\n     */\n    attachShadow(options) {\n      const { scopedElements } = /** @type {typeof ScopedElementsHost} */ (this.constructor);\n\n      const shouldCreateRegistry =\n        !this.registry ||\n        // @ts-ignore\n        (this.registry === this.constructor.__registry &&\n          !Object.prototype.hasOwnProperty.call(this.constructor, '__registry'));\n\n      /**\n       * Create a new registry if:\n       * - the registry is not defined\n       * - this class doesn't have its own registry *AND* has no shared registry\n       * This is important specifically for superclasses/inheritance\n       */\n      if (shouldCreateRegistry) {\n        this.registry = new CustomElementRegistry();\n        for (const [tagName, klass] of Object.entries(scopedElements ?? {})) {\n          this.registry.define(tagName, klass);\n        }\n      }\n\n      return super.attachShadow({\n        ...options,\n        // The polyfill currently expects the registry to be passed as `customElements`\n        customElements: this.registry,\n        // But the proposal has moved forward, and renamed it to `registry`\n        // For backwards compatibility, we pass it as both\n        registry: this.registry,\n      });\n    }\n  };\n\nexport const ScopedElementsMixin = dedupeMixin(ScopedElementsMixinImplementation);\n", "import { ScopedElementsMixin } from '@open-wc/scoped-elements/html-element.js';\nimport { LitElement } from 'lit';\n\n/** @typedef {import('@open-wc/scoped-elements/html-element.js').ScopedElementsMap} ScopedElementsMap */\n/** @typedef {import('lit/html.js').TemplateResult} TemplateResult */\n\n/**\n * Regarding the @ts-expect-error, it is caused by having '& typeof ScopedElementsHost' on ScopedElementsMixin.\n * This type intersection is necessary though, in order to access static props of the mixin. For example:\n *\n * static get scopedElements() {\n *   return {\n *     ...super.scopedElements, // <-- this will error without '& typeof ScopedElementsHost'\n *   }\n * }\n *\n * However, a new type error is created --> Base constructors must all have the same return type.ts(2510)\n * But this can be ignored, and then at least you do get the super static props typed properly.\n */\n// @ts-ignore https://github.com/microsoft/TypeScript/issues/40110 , not using expect-error, because in some TS versions it does not throw\nclass ScopedElementsTestWrapper extends ScopedElementsMixin(LitElement) {\n  static get properties() {\n    return {\n      scopedElements: { type: Object },\n      template: { type: Object },\n    };\n  }\n\n  constructor(scopedElement, template) {\n    super();\n\n    /** @type {ScopedElementsMap} */\n    this.scopedElements = scopedElement;\n\n    /** @type {import('./renderable.js').LitHTMLRenderable} */\n    this.template = template;\n  }\n\n  firstUpdated(_changed) {\n    super.firstUpdated(_changed);\n\n    Object.keys(this.scopedElements).forEach(key =>\n      // @ts-ignore\n      this.registry.define(key, this.scopedElements[key]),\n    );\n  }\n\n  render() {\n    return this.template;\n  }\n}\n\n/**\n * Obtains a unique tag name for the test wrapper\n * @param {number} [counter=0]\n * @returns {string}\n */\nconst getWrapperUniqueName = (counter = 0) => {\n  const tag = `scoped-elements-test-wrapper-${counter}`;\n\n  if (customElements.get(tag) !== undefined) {\n    return getWrapperUniqueName(counter + 1);\n  }\n\n  return tag;\n};\n\n/**\n * Wraps the template inside a scopedElements component\n *\n * @param {import('./renderable.js').LitHTMLRenderable} template\n * @param {ScopedElementsMap} scopedElements\n * @return {HTMLElement}\n */\nexport function getScopedElementsTemplate(template, scopedElements) {\n  const wrapperTagName = getWrapperUniqueName();\n  class Scope extends ScopedElementsTestWrapper {}\n\n  // @ts-ignore\n  customElements.define(wrapperTagName, Scope);\n\n  /** @type {ScopedElementsTestWrapper} */\n  const scope = new Scope(scopedElements, template);\n\n  return scope;\n}\n\n/** @typedef {typeof getScopedElementsTemplate} ScopedElementsTemplateGetter */\n"],
  "mappings": "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",
  "names": []
}
